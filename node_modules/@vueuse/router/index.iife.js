(function (exports, shared, vue, vueRouter) {
  'use strict';

  let _hash;
  function useRouteHash(defaultValue, {
    mode = "replace",
    route = vueRouter.useRoute(),
    router = vueRouter.useRouter()
  } = {}) {
    _hash = route.hash;
    shared.tryOnScopeDispose(() => {
      _hash = void 0;
    });
    let _trigger;
    const proxy = vue.customRef((track, trigger) => {
      _trigger = trigger;
      return {
        get() {
          track();
          return _hash || vue.toValue(defaultValue);
        },
        set(v) {
          if (v === _hash)
            return;
          _hash = v === null ? void 0 : v;
          trigger();
          vue.nextTick(() => {
            const { params, query } = route;
            router[vue.toValue(mode)]({ params, query, hash: _hash });
          });
        }
      };
    });
    vue.watch(
      () => route.hash,
      () => {
        if (route.hash === _hash)
          return;
        _hash = route.hash;
        _trigger();
      },
      { flush: "sync" }
    );
    return proxy;
  }

  const _queue$1 = /* @__PURE__ */ new WeakMap();
  function useRouteParams(name, defaultValue, options = {}) {
    const {
      mode = "replace",
      route = vueRouter.useRoute(),
      router = vueRouter.useRouter(),
      transform
    } = options;
    let transformGet = (value) => value;
    let transformSet = (value) => value;
    if (typeof transform === "function") {
      transformGet = transform;
    } else if (transform) {
      if (transform.get)
        transformGet = transform.get;
      if (transform.set)
        transformSet = transform.set;
    }
    if (!_queue$1.has(router))
      _queue$1.set(router, /* @__PURE__ */ new Map());
    const _paramsQueue = _queue$1.get(router);
    let param = route.params[name];
    shared.tryOnScopeDispose(() => {
      param = void 0;
    });
    let _trigger;
    const proxy = vue.customRef((track, trigger) => {
      _trigger = trigger;
      return {
        get() {
          track();
          return transformGet(param !== void 0 && param !== "" ? param : vue.toValue(defaultValue));
        },
        set(v) {
          v = transformSet(v);
          if (param === v)
            return;
          param = v === vue.toValue(defaultValue) || v === null ? void 0 : v;
          _paramsQueue.set(name, v === vue.toValue(defaultValue) || v === null ? void 0 : v);
          trigger();
          vue.nextTick(() => {
            if (_paramsQueue.size === 0)
              return;
            const newParams = Object.fromEntries(_paramsQueue.entries());
            _paramsQueue.clear();
            const { params, query, hash } = route;
            router[vue.toValue(mode)]({
              params: {
                ...params,
                ...newParams
              },
              query,
              hash
            });
          });
        }
      };
    });
    vue.watch(
      () => route.params[name],
      (v) => {
        if (param === transformGet(v))
          return;
        param = v;
        _trigger();
      },
      { flush: "sync" }
    );
    return proxy;
  }

  const _queue = /* @__PURE__ */ new WeakMap();
  function useRouteQuery(name, defaultValue, options = {}) {
    const {
      mode = "replace",
      route = vueRouter.useRoute(),
      router = vueRouter.useRouter(),
      transform
    } = options;
    let transformGet = (value) => value;
    let transformSet = (value) => value;
    if (typeof transform === "function") {
      transformGet = transform;
    } else if (transform) {
      if (transform.get)
        transformGet = transform.get;
      if (transform.set)
        transformSet = transform.set;
    }
    if (!_queue.has(router))
      _queue.set(router, /* @__PURE__ */ new Map());
    const _queriesQueue = _queue.get(router);
    let query = route.query[name];
    shared.tryOnScopeDispose(() => {
      query = void 0;
    });
    let _trigger;
    const proxy = vue.customRef((track, trigger) => {
      _trigger = trigger;
      return {
        get() {
          track();
          return transformGet(query !== void 0 ? query : vue.toValue(defaultValue));
        },
        set(v) {
          v = transformSet(v);
          if (query === v)
            return;
          query = v === vue.toValue(defaultValue) ? void 0 : v;
          _queriesQueue.set(name, v === vue.toValue(defaultValue) ? void 0 : v);
          trigger();
          vue.nextTick(() => {
            if (_queriesQueue.size === 0)
              return;
            const newQueries = Object.fromEntries(_queriesQueue.entries());
            _queriesQueue.clear();
            const { params, query: query2, hash } = route;
            router[vue.toValue(mode)]({
              params,
              query: { ...query2, ...newQueries },
              hash
            });
          });
        }
      };
    });
    vue.watch(
      () => route.query[name],
      (v) => {
        if (query === transformGet(v))
          return;
        query = v;
        _trigger();
      },
      { flush: "sync" }
    );
    return proxy;
  }

  exports.useRouteHash = useRouteHash;
  exports.useRouteParams = useRouteParams;
  exports.useRouteQuery = useRouteQuery;

})(this.VueUse = this.VueUse || {}, VueUse, Vue, VueRouter);
